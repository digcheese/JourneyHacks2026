<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coordinate Drawing Tool</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        .container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        .prompt-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .timer-display {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            font-size: 20px;
            font-weight: bold;
            color: #f44336;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }


        #drawingBtn {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            padding: 16px 48px;
            font-size: 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        #drawingBtn:hover {
            background: #45a049;
        }
        #drawingBtn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        #drawingBtn.hidden {
            display: none;
        }
        .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 5;
            opacity: 1;
            transition: opacity 0.6s ease-in-out;
            pointer-events: none;
        }
        .game-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .prompt-card-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: white;
            padding: 30px 150px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            width: auto;
            height: auto;
            opacity: 1;
            transition: transform 0.6s ease-in-out, opacity 0.6s ease-in-out;
        }
        .prompt-card-overlay.hidden {
            transform: translateX(-50%) translateY(100px);
            opacity: 0;
            pointer-events: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: white;
        }
        .results-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 999;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        .results-backdrop.show {
            opacity: 1;
            pointer-events: auto;
        }
        .results-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, calc(-50% + 100px));
            background: white;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            padding: 50px;
            transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
            opacity: 0;
            width: 90%;
            max-width: 800px;
            border-radius: 16px;
            overflow-y: auto;
            max-height: 90vh;
        }
        .results-panel.show {
            transform: translate(-50%, -50%);
            opacity: 1;
        }
        .results-content {
            display: flex;
            align-items: center;
            gap: 40px;
            flex-wrap: wrap;
        }
        .results-image {
            flex: 0 0 auto;
        }
        .results-image img {
            width: 350px;
            height: 260px;
            object-fit: contain;
            border: 3px solid #333;
            border-radius: 12px;
            background: white;
        }
        .results-info {
            flex: 1;
            min-width: 250px;
        }
        .results-info h2 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 32px;
        }
        .results-info .prompt-display-result {
            font-size: 22px;
            color: #666;
            margin-bottom: 20px;
        }
        .results-info .rating-display {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 30px;
            background: linear-gradient(to right, #f44336, #4CAF50);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .play-again-btn {
            padding: 12px 30px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        .play-again-btn:hover {
            background: #45a049;
        }
        .results-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .download-btn {
            padding: 12px 30px;
            font-size: 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        .download-btn:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="promptDisplay" class="prompt-display">Loading prompt...</div>
        <div id="promptCardOverlay" class="prompt-card-overlay"></div>
        <div id="gameOverlay" class="game-overlay"></div>
        <div id="countdownDisplay" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 120px; font-weight: bold; color: #4CAF50; z-index: 100; text-shadow: 2px 2px 4px rgba(0,0,0,0.2);"></div>
        <div id="timerDisplay" class="timer-display" style="display: none;"></div>
        <button id="drawingBtn">Start Drawing</button>
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // ============================================
        // GEMINI API KEY - REPLACE WITH YOUR KEY HERE
        // ============================================
        const GEMINI_API_KEY = 'AIzaSyDIaxZHEs45fcv76dUrZv49qft7yj4Vq6';
        // ============================================
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Initialize Socket.IO connection
        const socket = io();
        
        let isDrawing = false;
        let originX = null;
        let originY = null;
        let firstCoordX = null;
        let firstCoordY = null;
        let lastX = null;
        let lastY = null;
        let timerInterval = null;
        let countdownInterval = null;
        let timeRemaining = 60; // 1 minute in seconds
        let countdownRemaining = 3; // 3 second countdown
        let currentPrompt = '';
        let wordList = [];
        
        // Socket.IO event listener for new coordinates
        socket.on("new_coord", (data) => {
            if (!isDrawing) return;
            
            // Extract x and y coordinates from the data
            const x = data.x;
            const y = data.y;
            
            if (x !== undefined && y !== undefined) {
                processCoordinate(x, y);
            }
        });

        document.getElementById("drawingBtn").onclick = () => { 
            toggleDrawing();
            socket.emit("restart"); 
        };
        
        // Handle socket connection events
        socket.on("connect", () => {
            console.log("Connected to wand.py via Socket.IO");
        });
        
        socket.on("disconnect", () => {
            console.log("Disconnected from wand.py");
        });

        // Resize canvas to fill viewport
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Initialize canvas
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Word list embedded as array
        wordList = [
            'alien',
            'astronaut',
            'avocado',
            'babysitter',
            'bacon',
            'bald',
            'banana',
            'barista',
            'beaver',
            'botox',
            'Brazilian',
            'bride',
            'broccoli',
            'butt',
            'chihuahua',
            'clown',
            'cowboy',
            'crab',
            'DJ',
            'donut',
            'duck',
            'elf',
            'emoji',
            'fart',
            'flamingo',
            'gamer',
            'genie',
            'ghost',
            'gorilla',
            'groom',
            'hamster',
            'hotdog',
            'influencer',
            'jellyfish',
            'kangaroo',
            'karaoke',
            'ketchup',
            'Kim Kardashian',
            'king',
            'lifeguard',
            'llama',
            'magician',
            'mermaid',
            'model',
            'monkey',
            'mummy',
            'mustard',
            'nerd',
            'ninja',
            'octopus',
            'paparazzi',
            'penguin',
            'pirate',
            'poop',
            'potato',
            'queen',
            'rapper',
            'robot',
            'sandwich',
            'selfie stick',
            'skeleton',
            'sleepwalker',
            'sloth',
            'snail',
            'sniff',
            'snore',
            'surfer',
            'sushi',
            'taco',
            'tourist',
            'twerk',
            'unicorn',
            'vampire',
            'waiter',
            'watermelon',
            'yoga',
            'zombie'
        ];

        // Load word list and display random prompt
        function loadWordList() {
            displayRandomPrompt();
        }

        function displayRandomPrompt() {
            if (wordList.length === 0) return;
            const randomIndex = Math.floor(Math.random() * wordList.length);
            currentPrompt = wordList[randomIndex].trim();
            document.getElementById('promptDisplay').textContent = `Draw: ${currentPrompt}`;
            
            // Show overlays when displaying prompt
            document.getElementById('gameOverlay').classList.remove('hidden');
            document.getElementById('promptCardOverlay').classList.remove('hidden');
        }

        // Timer functions
        function startCountdown() {
            countdownRemaining = 3;
            const countdownDisplay = document.getElementById('countdownDisplay');
            countdownDisplay.style.display = 'block';
            countdownDisplay.textContent = countdownRemaining;
            
            // Hide overlays when countdown starts
            document.getElementById('gameOverlay').classList.add('hidden');
            document.getElementById('promptCardOverlay').classList.add('hidden');
            
            countdownInterval = setInterval(() => {
                countdownRemaining--;
                
                if (countdownRemaining > 0) {
                    countdownDisplay.textContent = countdownRemaining;
                } else {
                    // Countdown finished, hide display and start actual timer
                    countdownDisplay.style.display = 'none';
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    startTimer();
                }
            }, 1000);
        }

        function startTimer() {
            timeRemaining = 60;
            const timerDisplay = document.getElementById('timerDisplay');
            timerDisplay.style.display = 'block';
            updateTimerDisplay();
            
            timerInterval = setInterval(() => {
                timeRemaining--;
                updateTimerDisplay();
                
                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    onTimerEnd();
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            document.getElementById('timerDisplay').style.display = 'none';
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            const timerDisplay = document.getElementById('timerDisplay');
            timerDisplay.textContent = 
                `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Calculate color gradient from green to red based on time remaining
            // timeRemaining goes from 60 to 0, percentage goes from 100 to 0
            const percentage = (timeRemaining / 60) * 100;
            
            // Interpolate from green (#22c55e) to red (#ef4444)
            const red = Math.round(239 + (34 - 239) * (percentage / 100));
            const green = Math.round(69 + (197 - 69) * (percentage / 100));
            const blue = Math.round(68 + (68 - 68) * (percentage / 100));
            
            timerDisplay.style.color = `rgb(${red}, ${green}, ${blue})`;
        }

        async function onTimerEnd() {
            // Stop drawing
            isDrawing = false;
            stopPolling();
            document.getElementById('drawingBtn').disabled = true;
            document.getElementById('drawingBtn').textContent = 'Time\'s Up!';
            
            // Cover the prompt card immediately
            document.getElementById('promptCardOverlay').classList.remove('hidden');
            
            // Capture canvas with white background
            const imageData = captureCanvasWithWhiteBackground();
            
            // Send to Gemini for rating
            await rateDrawingWithGemini(imageData, currentPrompt);
        }

        // Function to capture canvas with completely white background
        function captureCanvasWithWhiteBackground() {
            // Create a temporary canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Fill with white background
            tempCtx.fillStyle = '#FFFFFF';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw the original canvas content on top
            tempCtx.drawImage(canvas, 0, 0);
            
            // Convert to image data
            return tempCanvas.toDataURL('image/png');
        }

        async function rateDrawingWithGemini(imageData, prompt) {
            try {
                // Convert base64 to base64 without data URL prefix
                const base64Image = imageData.split(',')[1];
                
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [
                                    {
                                        text: `Rate how close this drawing is to the prompt on a percentage scale. The prompt was: "${prompt}". 
                                        Do not send anything other than a percentage value. This drawing is a line drawing, so it may be hard to intrepret the details.
                                        Because of this, be a little more generous with your rating. Even if the drawing looks vague or nothing like the prompt. as long as the shape 
                                        is somewhat recognizable, give it a fair rating.`
                                    },
                                    {
                                        inline_data: {
                                            mime_type: 'image/png',
                                            data: base64Image
                                        }
                                    }
                                ]
                            }]
                        })
                    }
                );

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                const rating = data.candidates[0].content.parts[0].text.trim();
                
                // Display the results panel
                showResultsPanel(imageData, prompt, rating);
                
            } catch (error) {
                console.error('Error rating with Gemini:', error);
                showResultsPanel(imageData, prompt, 'Error getting rating');
            }
        }

        // Function to calculate gradient color based on percentage
        function getGradientColor(percentage) {
            // Clamp percentage between 0 and 100
            const pct = Math.max(0, Math.min(100, percentage));
            
            // Calculate RGB values: red (255,0,0) to green (0,255,0)
            const red = Math.round(255 * (1 - pct / 100));
            const green = Math.round(255 * (pct / 100));
            const blue = 0;
            
            return `rgb(${red}, ${green}, ${blue})`;
        }

        // Function to extract percentage from rating text
        function extractPercentage(ratingText) {
            // Try to extract number from text (handles formats like "50%", "50", "50 percent", etc.)
            const match = ratingText.match(/(\d+(?:\.\d+)?)/);
            if (match) {
                return parseFloat(match[1]);
            }
            return 50; // Default to 50% if can't parse
        }

        // Function to download results card as PNG
        function downloadResultsCard(prompt, rating, imageData) {
            // Create a canvas to draw the card (1400x600 total)
            const cardCanvas = document.createElement('canvas');
            cardCanvas.width = 1400;
            cardCanvas.height = 600;
            const cardCtx = cardCanvas.getContext('2d');
            
            // Fill background with light color
            cardCtx.fillStyle = '#f0f9f6';
            cardCtx.fillRect(0, 0, cardCanvas.width, cardCanvas.height);
            
            // Add border
            cardCtx.strokeStyle = '#a8d5ba';
            cardCtx.lineWidth = 8;
            cardCtx.strokeRect(25, 25, cardCanvas.width - 50, cardCanvas.height - 50);
            
            // Load and draw the drawing image
            const img = new Image();
            img.onload = function() {
                // Draw the drawing image on the left side (same size as rating card: 350x260)
                cardCtx.drawImage(img, 50, 120, 350, 260);
                
                // Add border around image
                cardCtx.strokeStyle = '#6ec98f';
                cardCtx.lineWidth = 5;
                cardCtx.strokeRect(50, 120, 350, 260);
                
                // Add prompt text on the right
                cardCtx.fillStyle = '#2d5a4a';
                cardCtx.font = 'bold 28px Arial';
                cardCtx.textAlign = 'left';
                cardCtx.fillText('Prompt: ' + prompt, 450, 150);
                
                // Add rating text with gradient color
                const percentage = extractPercentage(rating);
                const gradientColor = getGradientColor(percentage);
                cardCtx.fillStyle = gradientColor;
                cardCtx.font = 'bold 64px Arial';
                cardCtx.fillText('Rating: ' + rating, 450, 310);
                
                // Add "Picture Pitch" text at the bottom right
                cardCtx.fillStyle = '#2d5a4a';
                cardCtx.font = 'bold 32px Arial';
                cardCtx.textAlign = 'right';
                cardCtx.fillText('Picture Pitch', cardCanvas.width - 50, 560);
                
                // Download the canvas as PNG
                cardCanvas.toBlob(function(blob) {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = 'drawing-results.png';
                    link.click();
                    URL.revokeObjectURL(link.href);
                });
            };
            img.src = imageData;
        }

        // Function to show results panel
        function showResultsPanel(imageData, prompt, rating) {
            // Remove existing panel and backdrop if any
            const existingPanel = document.getElementById('resultsPanel');
            const existingBackdrop = document.getElementById('resultsBackdrop');
            if (existingPanel) {
                existingPanel.remove();
            }
            if (existingBackdrop) {
                existingBackdrop.remove();
            }
            
            // Extract percentage and calculate gradient color
            const percentage = extractPercentage(rating);
            const gradientColor = getGradientColor(percentage);
            
            // Create backdrop
            const backdrop = document.createElement('div');
            backdrop.id = 'resultsBackdrop';
            backdrop.className = 'results-backdrop';
            document.body.appendChild(backdrop);
            
            // Create results panel
            const panel = document.createElement('div');
            panel.id = 'resultsPanel';
            panel.className = 'results-panel';
            panel.innerHTML = `
                <div class="results-content">
                    <div class="results-image">
                        <img src="${imageData}" alt="Your drawing">
                    </div>
                    <div class="results-info">
                        <h2>Your Results</h2>
                        <div class="prompt-display-result">Prompt: <strong>${prompt}</strong></div>
                        <div class="rating-display" style="color: ${gradientColor};">Rating: ${rating}</div>
                        <div class="results-buttons">
                            <button class="play-again-btn" onclick="playAgain()">Play Again</button>
                            <button class="download-btn" onclick="downloadResultsCard('${prompt}', '${rating}', '${imageData}')">Download Card</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(panel);
            
            // Trigger slide-up animation
            setTimeout(() => {
                backdrop.classList.add('show');
                panel.classList.add('show');
            }, 10);
        }

        // Function to reset and play again
        function playAgain() {
            // Hide results panel and backdrop
            const panel = document.getElementById('resultsPanel');
            const backdrop = document.getElementById('resultsBackdrop');
            if (panel) {
                panel.classList.remove('show');
            }
            if (backdrop) {
                backdrop.classList.remove('show');
            }
            setTimeout(() => {
                if (panel) panel.remove();
                if (backdrop) backdrop.remove();
            }, 500);
            
            // Clear canvas
            clearCanvas();
            
            // Reset all drawing state
            isDrawing = false;
            originX = null;
            originY = null;
            firstCoordX = null;
            firstCoordY = null;
            lastX = null;
            lastY = null;
            
            // Stop any running timers
            stopPolling();
            stopTimer();
            
            // Reset button
            const btn = document.getElementById('drawingBtn');
            btn.textContent = 'Start Drawing';
            btn.classList.remove('hidden');
            btn.disabled = false;
            
            // Get new random prompt
            displayRandomPrompt();
        }

        // Load word list on page load
        loadWordList();

        function toggleDrawing() {
            const btn = document.getElementById('drawingBtn');
            
            if (!isDrawing) {
                // Starting drawing session
                isDrawing = true;
                btn.textContent = 'Drawing...';
                btn.disabled = true;
                btn.classList.add('hidden');
                
                // Clear canvas
                clearCanvas();
                
                // Reset origin when starting
                originX = null;
                originY = null;
                firstCoordX = null;
                firstCoordY = null;
                lastX = null;
                lastY = null;
                
                // Start 3-second countdown before drawing
                startCountdown();
                
                // Start polling for coordinates
                startPolling();
            } else {
                // Stopping drawing (shouldn't normally happen, but handle it)
                isDrawing = false;
                btn.textContent = 'Start Drawing';
                btn.classList.add('off');
                btn.classList.remove('hidden');
                btn.disabled = false;
                
                // Stop timer
                stopTimer();
                
                // Stop polling
                stopPolling();
            }
        }

        function startPolling() {
            // Socket.IO is already connected and listening
            // The "new_coord" event handler will process coordinates automatically
            console.log("Started listening for coordinates via Socket.IO");
        }

        function stopPolling() {
            // Socket.IO connection remains open, but coordinates won't be processed
            // because isDrawing flag will be false
            console.log("Stopped processing coordinates");
        }

        function processCoordinate(x, y) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            if (originX === null || originY === null) {
                // First coordinate - store its values and set as origin at center
                firstCoordX = x;
                firstCoordY = y;
                originX = centerX;
                originY = centerY;
                lastX = originX;
                lastY = originY;
                // Draw a point at the origin
                ctx.beginPath();
                ctx.arc(originX, originY, 3, 0, 2 * Math.PI);
                ctx.fill();
            } else {
                // Subsequent coordinates are relative to the first coordinate
                // Calculate relative offset from first coordinate
                const relativeX = x - firstCoordX;
                const relativeY = y - firstCoordY;
                
                // Draw at center + relative offset
                const screenX = originX + relativeX;
                const screenY = originY + relativeY;

                // Draw line from last point to new point
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(screenX, screenY);
                ctx.stroke();

                lastX = screenX;
                lastY = screenY;
            }
        }

        // Test coordinate input function
        function testCoordinate() {
            const input = document.getElementById('testCoord');
            const value = input.value.trim();
            
            if (!value) {
                alert('Please enter coordinates in format: x,y');
                return;
            }
            
            const parts = value.split(',');
            if (parts.length !== 2) {
                alert('Invalid format. Please use: x,y (e.g., 10,20)');
                return;
            }
            
            const x = parseFloat(parts[0].trim());
            const y = parseFloat(parts[1].trim());
            
            if (isNaN(x) || isNaN(y)) {
                alert('Please enter valid numbers');
                return;
            }
            
            // Process the coordinate as if it came from the JSON endpoint
            processCoordinate(x, y);
            
            // Clear input for next entry
            input.value = '';
            input.focus();
        }

        // Allow Enter key to submit test coordinate
        document.getElementById('testCoord').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                testCoordinate();
            }
        });

        // Clear canvas function (optional - can be added if needed)
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>
